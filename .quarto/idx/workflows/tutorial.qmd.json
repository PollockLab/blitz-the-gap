{"title":"Making priority maps for Blitz the Gap","markdown":{"yaml":{"title":"Making priority maps for Blitz the Gap","toc":true,"number-sections":true,"number-depth":1,"image":"images/map.png"},"headingText":"Example workflow with amphibians data","containsRefs":false,"markdown":"\n\n\nThis is an example workflow to identify gaps in a biodiversity database (like GBIF or iNaturalist), and to generate raster maps where each cell is assigned a priority level for sampling in a bioblitz event.\n\nEach map will cross biodiversity priorities with accessibility to identify the cells that are easiest to sample while helping to fill a biodiversity data gap. Gaps will be defined based on \"Challenges\" that will be part of the Blitz the Gap event.\n\nHere, we will build an example challenge to encourage community scientists to update historical records of amphibians.\n\n## Step 1. Prepare GBIF data and make density layers\n\nLoad packages:\n\n```{r, results='hide', message=FALSE,warning=FALSE}\nlibrary(dplyr) \nlibrary(tidyr)\nlibrary(terra)\nlibrary(ggplot2)\nlibrary(sf)\nlibrary(mapview)\nlibrary(raster)\nlibrary(here)\n```\n\nSet some mapview options to apply to all the maps we will make here:\n\n```{r}\nmapviewOptions(basemaps = c(\"OpenStreetMap\"),\n               na.color = \"transparent\")\n```\n\n### Spatial grid\n\nLoad spatial layers that we will use to make sure all of our layers match (in terms of the grid resolution and projection).\n\n```{r, eval = F}\n# Canada polygon\ncanada = sf::read_sf(\"~/McGill University/Laura's Lab_Group - BioBlitz/data/raw/base-layers/canada-polygon/canada.outline.shp\")\n\n# Base grid for rasterizing\nbase.5k = terra::rast(\"~/McGill University/Laura's Lab_Group - BioBlitz/data/raw/base-layers/canada.base.5k.tiff\")\n\n# Mask water and built areas\nbase.water <- rast(\"~/McGill University/Laura's Lab_Group - BioBlitz/data/raw/base-layers/WaterUrbanBuiltMask.tif\")\nbase.water<-project(base.water, crs(base.5k))\nbase.water<-resample(base.water, base.5k, method='near')\nterra::writeRaster(base.water, here::here(\"data/clean/base-layers/WaterUrbanBuiltMask.tif\"), overwrite=TRUE)\n\n# Make a reverse of the base layer to remove cells that we don't want to consider (later)\nanti.base=base.5k\nanti.base[is.na(anti.base)] <- 1\nanti.base[anti.base==2] <- NA\nanti.base[base.water==1] <- 1\nterra::writeRaster(anti.base, here::here(\"data/clean/base-layers/anti.base.5k.tif\"), overwrite = TRUE)\n```\n\n### Observations\n\nThis tutorial will use GBIF data, though later steps will be similarly useful to process iNaturalist data. Here, let's use a download of all amphibian data in Canada.\n\n```{r, eval = F}\n# Download the GBIF data through the GBIF data website. Make sure to save the citation details from the download in a text file alongside the data.\n# Unzip in the data/raw/gbif/your_taxa_of_choice folder\n# Read in the dataset and select columns we need\ngbif = data.table::fread(\"~/McGill University/Laura's Lab_Group - BioBlitz/data/raw/biodiversity-data/amphibians/0007149-250127130748423.csv\") |>\n  dplyr::filter(coordinateUncertaintyInMeters < 100000) |>\n  dplyr::select(family, scientificName, year,\n         decimalLongitude, decimalLatitude, coordinatePrecision,\n         datasetKey, basisOfRecord)\n```\n\nFirst, we need to prepare the GBIF data into a spatial object:\n\n```{r, eval = F}\n# Convert GBIF to a points layer\ngbif.v <- vect(gbif,\n               geom=c(\"decimalLongitude\",\"decimalLatitude\"),\n             crs=\"+proj=longlat +ellps=WGS84\",\n             keepgeom = TRUE)\n\n# Project GBIF \ngbif.v <- project(gbif.v, crs(base.5k))\n\n# Remove occurrences outside the canada polygon\ngbif.v = terra::crop(gbif.v, canada)\n```\n\nNow we can convert the GBIF data into raster layers:\n\n-   `gbif.density`: count of GBIF observations per cell\n\n-   `museum.density`: count of GBIF observations from preserved specimens (museums) per cell\n\n-   `iNat.density`: count of GBIF observations from iNaturalist (dataset key: `\"50c9509d-22c7-4a22-a47d-8c48425ef4a7\"`) per cell\n\n-   `year.last.sampled`: year of the last GBIF observation in GBIF per cell\n\n```{r, eval = F}\n# Make a GBIF density layer\ngbif.density <- rasterize(gbif.v, base.5k, fun=\"count\")\n\n# Density of museum observations\nmuseum.density <- rasterize(gbif.v[which(gbif.v$basisOfRecord == \"PRESERVED_SPECIMEN\")], base.5k, fun=\"count\")\n\n# Density of observations from iNaturalist alone\niNat.density <- rasterize(gbif.v[which(gbif.v$datasetKey == \"50c9509d-22c7-4a22-a47d-8c48425ef4a7\")], base.5k, fun=\"count\")\n\n# Raster of the latest observation's year\nyear.last.sampled <- rasterize(gbif.v, base.5k, fun=\"max\", field=\"year\")\n\n# Stack the GBIF layers into one object for easy saving\ngbif.layers = c(gbif.density,museum.density,iNat.density,year.last.sampled)\nnames(gbif.layers) = c(\"gbif.density\",\"museum.density\",\"iNat.density\",\"year.last.sampled\")\ngbif.layers[is.na(base.5k)]<-NA\n\n# save\nwriteRaster(gbif.layers, here::here(\"data/clean/biodiversity-data/rasters/gbif.layers.amphibians.tif\"), overwrite = TRUE)\nwriteVector(gbif.v, here::here(\"data/clean/biodiversity-data/points/gbif.points.amphibians.shp\"), overwrite = TRUE)\n```\n\n## Step 2. Prepare environmental & human access layers\n\nMany of these layers are originally from the GEOBON STAC catalog, which can be viewed here: <https://stac.geobon.org/viewer/>. Instructions about how to retrieve these layers and download them for use are here: [Working with STAC](https://geo-bon.github.io/bon-in-a-box-pipeline-engine/working_with_stac.html).\n\nThis is some code to reproject and resample the rasters from the STAC to match the GBIF density layers, after downloading them following the instructions linked above.\n\n### Environmental layers\n\nClimate velocity (a metric of how quickly the climate will change by 2085 in each cell, under RCP85):\n\n```{r, eval = F}\nvel <- rast(\"~/McGill University/Laura's Lab_Group - BioBlitz/data/raw/challenges/climate/climatevelocity_adaptwest_fwvel_ensemble_rcp85_2085.tif\")\nvel<-project(vel,base.5k,\"bilinear\")\nvel<-resample(vel,base.5k,method='near')\nvel[is.na(base.5k)] <- NA\nterra::writeRaster(vel, here::here(\"data/clean/challenges/climate/climatevelocity_adaptwest_fwvel_ensemble_rcp85_2085.tif\"), overwrite=TRUE)\n```\n\n### Accessibility\n\nDistance to roads:\n\n```{r, eval = F}\ndist.to.roads<-rast(\"~/McGill University/Laura's Lab_Group - BioBlitz/data/raw/base-layers/distance.to.roads.tif\")\ndist.to.roads<-project(dist.to.roads,base.5k,\"bilinear\")\ndist.to.roads[is.na(base.5k)]<-NA\nterra::writeRaster(dist.to.roads, here::here(\"data/clean/base-layers/dist.to.roads.tif\"),overwrite = TRUE)\n```\n\n```{r, echo = FALSE, include=FALSE}\n# hidden chunk to load datasets prepared with the code above\ngbif.layers = terra::rast(here::here(\"data/clean/biodiversity-data/rasters/gbif.layers.amphibians.tif\"))\ngbif.v = terra::vect(here::here(\"data/clean/biodiversity-data/points/gbif.points.amphibians.shp\"))\ndist.to.roads = terra::rast(here::here(\"data/clean/base-layers/dist.to.roads.tif\"))\n```\n\n## Step 3. Make a priority map\n\n### Biodiversity data gap priority: Updating historical data\n\n```{r}\n# Copy the layer into a new object that we'll edit\nresamp <- gbif.layers$year.last.sampled\nmapview(resamp, \n        na.color = \"transparent\")\n```\n\nNext, we will assign priority values to cells based on the year they were last sampled. These are the priority levels we will use:\n\n| Priority           | Oldest observation | Newest observation |\n|--------------------|--------------------|--------------------|\n| High (1)           | oldest             | 1950               |\n| Medium (2)         | 1951               | 2000               |\n| Low (3)            | 2001               | 2015               |\n| Not a priority (4) | 2016               | 2025               |\n\nLet's assign these values based on the condition that the year last sampled in GBIF is within those year limits:\n\n```{r}\nresamp[gbif.layers$year.last.sampled <= 1950] <- 1\nresamp[gbif.layers$year.last.sampled > 1950 & gbif.layers$year.last.sampled <= 2000] <- 2\nresamp[gbif.layers$year.last.sampled > 2000 & gbif.layers$year.last.sampled <= 2015] <- 3\nresamp[gbif.layers$year.last.sampled > 2015] <- 4\n```\n\nLet's map this to see what we're working with!\n\n```{r}\nmapview(resamp)\n```\n\n### Mask to accessible pixels\n\nLet's make a mask of the pixels we consider to be accessible. Let's say anything within 10 km of a major road is potentially accessible, so we're only interested in these cells:\n\n```{r}\nd10 = dist.to.roads\nd10[d10>10000] <- NA # assign NA to pixels that are over 10 km away from a major road\nmapview(d10)\n```\n\nNow, we can use this same condition (ignore anything where `dist.to.roads > 10000`) to select cells from the priority layer that are accessible:\n\n```{r}\npal = viridis::viridis(n = 3, direction = -1)\npriority = resamp\npriority[dist.to.roads > 10000] <- NA\nmapview(priority, \n        col.regions = pal)\n```\n\n### Make a final interactive map\n\nLet's visualize this a little differently, so it is easier to explore. We will make a point layer with the year in which the cell was last sampled, and this layer is resized as we zoom in and out so it is easier to have a quick view of the map. When we zoom in, we will see the cell the point is referring to, so we make sure we're still identifying the exact cell outline that we'd be asking people to go sample.\n\n```{r}\nlast.year = gbif.layers$year.last.sampled\nlast.year[priority > 3] <- NA\nlast.year[dist.to.roads > 10000] <- NA\n\nhistorical_pts = last.year |>\n  raster::raster() |>\n  raster::rasterToPoints(fun = function(x){x<2016}, spatial = TRUE)\n\nhistorical_cells = priority |>\n  raster::raster() |>\n  raster::rasterToPolygons(fun = function(x){x < 4})\n\npal = viridis::viridis(n = 3, direction = -1)\n(m = mapview(historical_cells, \n        legend = TRUE, \n        basemaps = \"OpenStreetMap\",  \n        col.regions = pal,\n        layer.name = \"Priority\") +\n  mapview(historical_pts,\n          col.regions = pal,\n          legend = FALSE, \n          layer.name = \"Year last \\nsampled\"))\n```\n\n```{r}\nhtmlwidgets::saveWidget(m@map, \n                        file = here::here(\"challenges/maps/challenge1_map.html\"), \n                        title = \"Revisit the past: Amphibians\")\n```\n\n\n## Prepare KML file for iNaturalist\n\nTo make a project on iNaturalist that includes observations within polygons, we need to convert our raster into a KML file. From this KML file, we can make a \"Place\" on iNaturalist, which we can then set up for each challenge.\n\nFirst, we will convert our raster to polygons using the `raster` package:\n\n```{r}\n# make a raster layer to convert \npriority_map = priority\n# remove lowest priority level to only have 3 levels\npriority_map[priority > 3] <- NA\n\n# convert raster to polygons\nhistorical_poly = raster::raster(priority_map) |>\n  raster::rasterToPolygons(n = 4, \n                           na.rm = TRUE)\n\n## Merge polygons that are touching into one polygon\n# convert to sf object\nhistorical_poly = sf::st_as_sf(historical_poly) \n\n# write polygons as a kml file\nsf::st_write(historical_poly, \n             driver = \"KML\", \n             dsn = here::here(\"data/outputs/kml/historical-amphibians.kml\"),\n             delete_layer = TRUE) # overwrite existing layer\n```\n\n\n","srcMarkdownNoYaml":"\n\n# Example workflow with amphibians data\n\nThis is an example workflow to identify gaps in a biodiversity database (like GBIF or iNaturalist), and to generate raster maps where each cell is assigned a priority level for sampling in a bioblitz event.\n\nEach map will cross biodiversity priorities with accessibility to identify the cells that are easiest to sample while helping to fill a biodiversity data gap. Gaps will be defined based on \"Challenges\" that will be part of the Blitz the Gap event.\n\nHere, we will build an example challenge to encourage community scientists to update historical records of amphibians.\n\n## Step 1. Prepare GBIF data and make density layers\n\nLoad packages:\n\n```{r, results='hide', message=FALSE,warning=FALSE}\nlibrary(dplyr) \nlibrary(tidyr)\nlibrary(terra)\nlibrary(ggplot2)\nlibrary(sf)\nlibrary(mapview)\nlibrary(raster)\nlibrary(here)\n```\n\nSet some mapview options to apply to all the maps we will make here:\n\n```{r}\nmapviewOptions(basemaps = c(\"OpenStreetMap\"),\n               na.color = \"transparent\")\n```\n\n### Spatial grid\n\nLoad spatial layers that we will use to make sure all of our layers match (in terms of the grid resolution and projection).\n\n```{r, eval = F}\n# Canada polygon\ncanada = sf::read_sf(\"~/McGill University/Laura's Lab_Group - BioBlitz/data/raw/base-layers/canada-polygon/canada.outline.shp\")\n\n# Base grid for rasterizing\nbase.5k = terra::rast(\"~/McGill University/Laura's Lab_Group - BioBlitz/data/raw/base-layers/canada.base.5k.tiff\")\n\n# Mask water and built areas\nbase.water <- rast(\"~/McGill University/Laura's Lab_Group - BioBlitz/data/raw/base-layers/WaterUrbanBuiltMask.tif\")\nbase.water<-project(base.water, crs(base.5k))\nbase.water<-resample(base.water, base.5k, method='near')\nterra::writeRaster(base.water, here::here(\"data/clean/base-layers/WaterUrbanBuiltMask.tif\"), overwrite=TRUE)\n\n# Make a reverse of the base layer to remove cells that we don't want to consider (later)\nanti.base=base.5k\nanti.base[is.na(anti.base)] <- 1\nanti.base[anti.base==2] <- NA\nanti.base[base.water==1] <- 1\nterra::writeRaster(anti.base, here::here(\"data/clean/base-layers/anti.base.5k.tif\"), overwrite = TRUE)\n```\n\n### Observations\n\nThis tutorial will use GBIF data, though later steps will be similarly useful to process iNaturalist data. Here, let's use a download of all amphibian data in Canada.\n\n```{r, eval = F}\n# Download the GBIF data through the GBIF data website. Make sure to save the citation details from the download in a text file alongside the data.\n# Unzip in the data/raw/gbif/your_taxa_of_choice folder\n# Read in the dataset and select columns we need\ngbif = data.table::fread(\"~/McGill University/Laura's Lab_Group - BioBlitz/data/raw/biodiversity-data/amphibians/0007149-250127130748423.csv\") |>\n  dplyr::filter(coordinateUncertaintyInMeters < 100000) |>\n  dplyr::select(family, scientificName, year,\n         decimalLongitude, decimalLatitude, coordinatePrecision,\n         datasetKey, basisOfRecord)\n```\n\nFirst, we need to prepare the GBIF data into a spatial object:\n\n```{r, eval = F}\n# Convert GBIF to a points layer\ngbif.v <- vect(gbif,\n               geom=c(\"decimalLongitude\",\"decimalLatitude\"),\n             crs=\"+proj=longlat +ellps=WGS84\",\n             keepgeom = TRUE)\n\n# Project GBIF \ngbif.v <- project(gbif.v, crs(base.5k))\n\n# Remove occurrences outside the canada polygon\ngbif.v = terra::crop(gbif.v, canada)\n```\n\nNow we can convert the GBIF data into raster layers:\n\n-   `gbif.density`: count of GBIF observations per cell\n\n-   `museum.density`: count of GBIF observations from preserved specimens (museums) per cell\n\n-   `iNat.density`: count of GBIF observations from iNaturalist (dataset key: `\"50c9509d-22c7-4a22-a47d-8c48425ef4a7\"`) per cell\n\n-   `year.last.sampled`: year of the last GBIF observation in GBIF per cell\n\n```{r, eval = F}\n# Make a GBIF density layer\ngbif.density <- rasterize(gbif.v, base.5k, fun=\"count\")\n\n# Density of museum observations\nmuseum.density <- rasterize(gbif.v[which(gbif.v$basisOfRecord == \"PRESERVED_SPECIMEN\")], base.5k, fun=\"count\")\n\n# Density of observations from iNaturalist alone\niNat.density <- rasterize(gbif.v[which(gbif.v$datasetKey == \"50c9509d-22c7-4a22-a47d-8c48425ef4a7\")], base.5k, fun=\"count\")\n\n# Raster of the latest observation's year\nyear.last.sampled <- rasterize(gbif.v, base.5k, fun=\"max\", field=\"year\")\n\n# Stack the GBIF layers into one object for easy saving\ngbif.layers = c(gbif.density,museum.density,iNat.density,year.last.sampled)\nnames(gbif.layers) = c(\"gbif.density\",\"museum.density\",\"iNat.density\",\"year.last.sampled\")\ngbif.layers[is.na(base.5k)]<-NA\n\n# save\nwriteRaster(gbif.layers, here::here(\"data/clean/biodiversity-data/rasters/gbif.layers.amphibians.tif\"), overwrite = TRUE)\nwriteVector(gbif.v, here::here(\"data/clean/biodiversity-data/points/gbif.points.amphibians.shp\"), overwrite = TRUE)\n```\n\n## Step 2. Prepare environmental & human access layers\n\nMany of these layers are originally from the GEOBON STAC catalog, which can be viewed here: <https://stac.geobon.org/viewer/>. Instructions about how to retrieve these layers and download them for use are here: [Working with STAC](https://geo-bon.github.io/bon-in-a-box-pipeline-engine/working_with_stac.html).\n\nThis is some code to reproject and resample the rasters from the STAC to match the GBIF density layers, after downloading them following the instructions linked above.\n\n### Environmental layers\n\nClimate velocity (a metric of how quickly the climate will change by 2085 in each cell, under RCP85):\n\n```{r, eval = F}\nvel <- rast(\"~/McGill University/Laura's Lab_Group - BioBlitz/data/raw/challenges/climate/climatevelocity_adaptwest_fwvel_ensemble_rcp85_2085.tif\")\nvel<-project(vel,base.5k,\"bilinear\")\nvel<-resample(vel,base.5k,method='near')\nvel[is.na(base.5k)] <- NA\nterra::writeRaster(vel, here::here(\"data/clean/challenges/climate/climatevelocity_adaptwest_fwvel_ensemble_rcp85_2085.tif\"), overwrite=TRUE)\n```\n\n### Accessibility\n\nDistance to roads:\n\n```{r, eval = F}\ndist.to.roads<-rast(\"~/McGill University/Laura's Lab_Group - BioBlitz/data/raw/base-layers/distance.to.roads.tif\")\ndist.to.roads<-project(dist.to.roads,base.5k,\"bilinear\")\ndist.to.roads[is.na(base.5k)]<-NA\nterra::writeRaster(dist.to.roads, here::here(\"data/clean/base-layers/dist.to.roads.tif\"),overwrite = TRUE)\n```\n\n```{r, echo = FALSE, include=FALSE}\n# hidden chunk to load datasets prepared with the code above\ngbif.layers = terra::rast(here::here(\"data/clean/biodiversity-data/rasters/gbif.layers.amphibians.tif\"))\ngbif.v = terra::vect(here::here(\"data/clean/biodiversity-data/points/gbif.points.amphibians.shp\"))\ndist.to.roads = terra::rast(here::here(\"data/clean/base-layers/dist.to.roads.tif\"))\n```\n\n## Step 3. Make a priority map\n\n### Biodiversity data gap priority: Updating historical data\n\n```{r}\n# Copy the layer into a new object that we'll edit\nresamp <- gbif.layers$year.last.sampled\nmapview(resamp, \n        na.color = \"transparent\")\n```\n\nNext, we will assign priority values to cells based on the year they were last sampled. These are the priority levels we will use:\n\n| Priority           | Oldest observation | Newest observation |\n|--------------------|--------------------|--------------------|\n| High (1)           | oldest             | 1950               |\n| Medium (2)         | 1951               | 2000               |\n| Low (3)            | 2001               | 2015               |\n| Not a priority (4) | 2016               | 2025               |\n\nLet's assign these values based on the condition that the year last sampled in GBIF is within those year limits:\n\n```{r}\nresamp[gbif.layers$year.last.sampled <= 1950] <- 1\nresamp[gbif.layers$year.last.sampled > 1950 & gbif.layers$year.last.sampled <= 2000] <- 2\nresamp[gbif.layers$year.last.sampled > 2000 & gbif.layers$year.last.sampled <= 2015] <- 3\nresamp[gbif.layers$year.last.sampled > 2015] <- 4\n```\n\nLet's map this to see what we're working with!\n\n```{r}\nmapview(resamp)\n```\n\n### Mask to accessible pixels\n\nLet's make a mask of the pixels we consider to be accessible. Let's say anything within 10 km of a major road is potentially accessible, so we're only interested in these cells:\n\n```{r}\nd10 = dist.to.roads\nd10[d10>10000] <- NA # assign NA to pixels that are over 10 km away from a major road\nmapview(d10)\n```\n\nNow, we can use this same condition (ignore anything where `dist.to.roads > 10000`) to select cells from the priority layer that are accessible:\n\n```{r}\npal = viridis::viridis(n = 3, direction = -1)\npriority = resamp\npriority[dist.to.roads > 10000] <- NA\nmapview(priority, \n        col.regions = pal)\n```\n\n### Make a final interactive map\n\nLet's visualize this a little differently, so it is easier to explore. We will make a point layer with the year in which the cell was last sampled, and this layer is resized as we zoom in and out so it is easier to have a quick view of the map. When we zoom in, we will see the cell the point is referring to, so we make sure we're still identifying the exact cell outline that we'd be asking people to go sample.\n\n```{r}\nlast.year = gbif.layers$year.last.sampled\nlast.year[priority > 3] <- NA\nlast.year[dist.to.roads > 10000] <- NA\n\nhistorical_pts = last.year |>\n  raster::raster() |>\n  raster::rasterToPoints(fun = function(x){x<2016}, spatial = TRUE)\n\nhistorical_cells = priority |>\n  raster::raster() |>\n  raster::rasterToPolygons(fun = function(x){x < 4})\n\npal = viridis::viridis(n = 3, direction = -1)\n(m = mapview(historical_cells, \n        legend = TRUE, \n        basemaps = \"OpenStreetMap\",  \n        col.regions = pal,\n        layer.name = \"Priority\") +\n  mapview(historical_pts,\n          col.regions = pal,\n          legend = FALSE, \n          layer.name = \"Year last \\nsampled\"))\n```\n\n```{r}\nhtmlwidgets::saveWidget(m@map, \n                        file = here::here(\"challenges/maps/challenge1_map.html\"), \n                        title = \"Revisit the past: Amphibians\")\n```\n\n\n## Prepare KML file for iNaturalist\n\nTo make a project on iNaturalist that includes observations within polygons, we need to convert our raster into a KML file. From this KML file, we can make a \"Place\" on iNaturalist, which we can then set up for each challenge.\n\nFirst, we will convert our raster to polygons using the `raster` package:\n\n```{r}\n# make a raster layer to convert \npriority_map = priority\n# remove lowest priority level to only have 3 levels\npriority_map[priority > 3] <- NA\n\n# convert raster to polygons\nhistorical_poly = raster::raster(priority_map) |>\n  raster::rasterToPolygons(n = 4, \n                           na.rm = TRUE)\n\n## Merge polygons that are touching into one polygon\n# convert to sf object\nhistorical_poly = sf::st_as_sf(historical_poly) \n\n# write polygons as a kml file\nsf::st_write(historical_poly, \n             driver = \"KML\", \n             dsn = here::here(\"data/outputs/kml/historical-amphibians.kml\"),\n             delete_layer = TRUE) # overwrite existing layer\n```\n\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","embed-resources":true,"toc":true,"number-sections":true,"output-file":"tutorial.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.6.41","theme":["yeti","../custom.scss"],"smooth-scroll":true,"fontsize":"12pt","grid":{"margin-width":"0px"},"title":"Making priority maps for Blitz the Gap","number-depth":1,"image":"images/map.png"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}